{\rtf1\ansi\ansicpg1252\deff0\deflang1033{\fonttbl{\f0\fswiss\fcharset0 Arial;}{\f1\fswiss\fcharset0 Tahoma;}}
{\colortbl ;\red0\green0\blue0;\red0\green0\blue255;\red255\green0\blue0;\red0\green127\blue0;\red0\green0\blue127;}
{\*\generator Msftedit 5.41.15.1507;}\viewkind4\uc1\pard\cf1\lang2057\f0\fs18\par
\b\fs32\par
C# Coding Convention \b0\fs14 v1.0\b\fs32\par
\i\fs18 Editor: Le Hong Son. G1-D8 FPT Software.\par
\i0\par
\i\par
Introduction:\par
\b0\i0\par
\f1\fs20 This document sets out the standards that C# code produced. It is aimed at production teams at Microsoft to ensure that our software product have the highest standards and are coded in the most professional way.\par
\par
\par
Lastly remember that these rules are not fixed. If you have any suggestions or improvements then make them known. \par
\par
\f0\fs18\par
\cf2\b\f1\fs29 1 Naming Conventions and Style\par
\cf1\b0\fs20 1. Use Pascal casing for type and method names\par
\cf2\fs18 public class \cf1 SomeClass\par
\{\par
\cf2 public \cf1 Som\b e\b0 Method()\{\}\par
\}\par
\fs20 2. Use camel casing for local variable names and method arguments\par
\cf2\fs18 int \cf1 number;\par
\cf2 void \cf1 MyMethod(\cf2 int \cf1 someNumber)\par
\{\}\par
\fs20 3. Name interfaces with \cf3 I \cf1 prefix\par
\cf2\fs18 interface \cf1 IMyInterface\par
\{..\}\par
\fs20 4. Prefix private member variables with \cf3 m_\par
\cf2\fs18 public class \cf1 SomeClass\par
\{\par
\cf2 private int \cf1\b m_\b0 Number;\par
\}\par
\fs20 5. Suffix custom attribute classes with Attribute.\par
6. Suffix custom exception classes with Exception.\par
7. Name methods using verb-object pair, such as \cf3 ShowDialog()\par
\cf1 8. Methods with return values should have a name describing the value returned, such\par
as \cf3 GetObjectState(\cf1 ).\par
9. Use delegate inference instead of explicit delegate instantiation.\par
10. With generics, use capital letters for types. Reserve suffixing \cf3 Type \cf1 when dealing\par
with the .NET type \cf3 Typ\cf1 e.\par
\cf4\fs18 //Correct:\par
\cf2 public class \cf1 LinkedList<K,T>\par
\{\'85\}\par
\cf4 //Avoid:\par
\cf2 public class \cf1 LinkedList<KeyType,DataType>\par
\{\'85\}\par
\fs20 11. Maintain strict indentation.\par
a) Use 3 spaces for indentation.\par
b) Do not use tabs or non-standard indentation like 1, 2 or 4 spaces.\par
12. Indent comment at the same level of indentation as the code you are documenting.\par
13. All comments should pass spell checking. Misspelled comments indicate sloppy\par
development.\par
14. Use descriptive variable names.\par
a) Avoid one character variable names, such as \cf3 i \cf1 or t. Use \cf3 index \cf1 or \cf3 temp\par
\cf1 instead.\par
b) Avoid using Hungarian notation for public or protected members\fs17\par
\fs20 c) Do not abbreviate words (such as \cf3 num \cf1 instead of \cf3 numbe\cf1 r).\par
15. All member variables should be declared at the top, with one line separating them\par
from the properties or methods.\par
\cf2\fs18 public class \cf1 MyClass\par
\{\par
\cf2\b int \cf1 m_Number;\par
\cf2 string \cf1 m_Name;\par
\cf2\b0 public void \cf1 SomeMethod1()\{\}\par
\cf2 public void \cf1 SomeMethod2()\{\}\par
\cf4\}\par
\cf1\fs20 16. Declare a local variable as close as possible to its first use.\par
17. Use meaningful namespaces such as the product name, company name, etc.\par
18. Avoid fully qualified type names. Use the \cf3 using \cf1 statement instead.\par
19. Avoid putting a \cf3 using \cf1 statement inside a namespace.\par
20. Group all framework namespaces together and put custom or third party namespaces\par
beneath.\par
\cf2\fs18 using \cf1 System;\par
\cf2 using \cf1 System.Collections;\par
\cf2 using \cf1 System.ComponentModel;\par
\cf2 using \cf1 System.Data;\par
\cf2 using \cf1 MyCompany;\par
\cf2 using \cf1 MyControl\cf4 s;\par
\par
\cf1\fs20 21. A file name should reflect the class it contains.\par
22. Always place an open curly brace ( \{) in a new line.\par
23. With anonymous methods mimic the code layout of a regular method, aligned with\par
the anonymous delegate declaration.\par
a) Comply with placing an open curly brace in a new line\par
\cf2\fs18 delegate void \cf1 SomeDelegate(\cf2 string \cf1 str);\par
\cf4 //Correct:\par
\cf2 public void \cf1 InvokeMethod()\par
\{\par
SomeDelegate del = \cf2 delegat\cf1 e(\cf2 string \cf1 str)\par
\{\par
MessageBox.Show(str);\par
\};\par
del("Hello");\par
\}\par
\cf4 //Avoid\par
\cf2 public void \cf1 InvokeMethod()\par
\{\par
SomeDelegate del = \cf2 delegat\cf1 e(\cf2 string \cf1 str)\{MessageBox.Show(str);\};\par
del("Hello");\par
\}\par
\fs20 24. Use empty parenthesis on parameter-less anonymous methods.\par
a) Omit the parenthesis only if the anonymous method could have been used on any\par
delegate.\par
\par
\cf2\b\fs29 2 Coding\par
\cf1\b0\fs20 1. Always use C# predefined types rather than the aliases in the \cf3 System \cf1 namespace.\par
For example:\par
\cf2\fs18 object \cf1 NOT Object\par
\cf2 string \cf1 NOT String\par
\cf2 int \cf1 NOT Int32\par
\fs20 2. Avoid putting multiple classes in a single file.\par
3. A single file should only contribute types to a single namespace. Avoid having\par
multiple namespaces in the same file.\par
4. Avoid files with more than 500 lines (excluding machine-generated code).\par
5. Avoid methods with more than 25 lines.\par
6. Avoid methods with more than 5 arguments. Use structures for passing multiple\par
arguments.\par
7. Lines should not exceed 80 characters.\par
8. Do not manually edit any machine generated code.\par
9. If modifying machine generated code, modify the format and style to match this\par
coding standard.\par
a) Use partial classes if possible.\par
10. Avoid comments that explain the obvious.\par
11. Code should be self explanatory. Good code with readable variable and method\par
names should not require comments.\par
12. Document only operational assumptions, algorithm insights etc.\par
13. Avoid method-level documentation.\par
a) Use extensive external documentation for API documentation.\par
b) Use method-level comments only as tool tips for other developers.\par
14. Never hard-code a numeric value, always declare a constant instead.\par
15. Assert every assumption.\par
16. On average, every fifth line is an assertion.\par
\cf2\fs18 using \cf1 System.Diagnostics;\par
\cf2 object \cf1 GetObject()\par
\{\'85\}\par
\cf2 object \cf1 obj = GetObject();\par
\b Debug.Assert(obj != \cf2 nul\cf1 l);\par
\b0\fs20 17. Make only the most necessary types public, mark others as internal.\par
18. Always use zero-based arrays.\par
19. Avoid providing explicit values for enums.\par
20. Avoid specifying a type for an enum (like \cf3 lon\cf1 g).\par
21. Never use \cf3 goto \cf1 unless in a switch statement fall-through\par
\fs17\par
\fs20 22. Avoid function calls in Boolean conditional statements. Assign into local variables\par
and check on them:\par
\cf2\fs18 bool \cf1 IsEverythingOK()\par
\{\'85\}\par
\cf4 //Avoid:\par
\cf2 i\cf1 f(IsEverythingOK())\par
\{\'85\}\par
\cf4 //Instead:\par
\cf2 bool \cf1 ok = IsEverythingOK();\par
\cf2 i\cf1 f(ok)\par
\{\'85\}\par
\fs20 23. Always explicitly initialize an array of reference types using a \cf3 for \cf1 loop.\par
\cf2\fs18 public class \cf1 MyClass\par
\{\}\par
MyClass[] array = \cf2 new \cf1 MyClass[100];\par
\cf2 fo\cf1 r(\cf2 int \cf1 index = 0; index < array.Length; index++)\par
\{\par
array[index] = \cf2\b new \cf1\b0 MyClass();\par
\}\par
\fs20 24. Only catch exceptions for which you have explicit handling.\par
25. In a catch statement that throws an exception, always throw the original exception to\par
maintain stack location of original error.\par
\cf2\fs18 catc\cf1 h(Exception exception)\par
\{\par
MessageBox.Show(exception.Message);\par
\cf2\b thro\cf1\b0 w; \cf4 //Same as throw exception;\par
\cf1\}\par
\fs20 26. Avoid error code as methods return values.\par
27. Do not use the \cf3 new \cf1 inheritance qualifier. Use \cf3 override \cf1 instead.\par
28. Minimize code in application assemblies (EXE client assemblies), use class libraries\par
instead to contain business logic.\par
29. Never hardcode strings that will be presented to end users. Use resources instead.\par
30. Never hardcode strings that might change based on deployment such as connection\par
strings.\par
31. Never use unsafe code unless when using interop.\par
32. Always use interfaces.\par
33. Avoid multiple \cf3 Main() \cf1 methods in a single assembly.\par
\fs17\par
\fs20 34. Avoid explicit casting. Use the \cf3 as \cf1 operator to defensively cast to a type.\par
\fs18 Dog dog = \cf2 new \cf1 GermanShepherd();\par
GermanShepherd shepherd = dog \cf2\b as \cf1\b0 GermanShepherd;\par
\cf2 i\cf1 f(shepherd != \cf2 nul\cf1 l)\par
\cf4\{\'85\}\par
\cf1\fs20 35. Never assume a type supports an interface. Defensively query for that interface.\par
\fs18 SomeType obj1;\par
IMyInterface obj2;\par
\cf4 /* Some code to initialize obj1, then: */\par
\cf1 obj2 = obj1 \cf2 as \cf1 IMyInterface;\par
\cf2 i\cf1 f(obj2 != \cf2 nul\cf1 l)\par
\{\par
obj2.Method1();\par
\}\par
\cf2 else\par
\cf1\{\par
\cf4 //Handle error in expected interface\par
\cf1\}\par
\fs20 36. Do not provide public or protected member variables. Use properties instead.\par
37. Do not provide public event member variables. Use event accessors instead.\par
\cf2\fs18 public class \cf1 MySource\par
\{\par
MyDelegate m_NumberChangedEvent;\par
\cf2 public event \cf1 MyDelegate NumberChangedEvent\par
\{\par
\cf2 add\par
\cf1\{\par
m_NumberChangedEvent += \cf2 valu\cf1 e;\par
\}\par
\cf2 remove\par
\cf1\{\par
m_NumberChangedEvent -= \cf2 valu\cf1 e;\par
\}\par
\}\par
\cf4\}\par
\cf1\fs20 38. Classes and interfaces should have at least 2:1 ratio of methods to properties.\par
39. Avoid interfaces with one member.\par
40. Strive to have 3-5 members per interface.\par
41. No more than 20 members per interface.\par
42. Avoid events as interface members.\par
43. Avoid abstract methods, use interfaces instead.\par
44. Always prefer using C# generics in data structures.\par
45. Expose interfaces on class hierarchies.\par
\fs17\par
\fs20 46. Prefer using explicit interface implementation.\par
47. Always mark public and protected methods as \cf3 virtual \cf1 in a non sealed class.\par
48. When building a long string, use \cf3 StringBuilde\cf1 r, not string.\par
49. Always use a curly brace scope in an \cf3 if \cf1 statement, even if it conditions a single\par
statement.\par
50. With delegates as class members:\par
a) Copy a delegate to a local variable before publishing to avoid concurrency race\par
condition.\par
b) Always check a delegate for null before invoking it.\par
\cf2\fs18 public class \cf1 MySource\par
\{\par
\cf2 public event \cf1 EventHandler MyEvent;\par
\cf2 public void \cf1 FireEvent()\par
\{\par
EventHandler temp = MyEvent;\par
\cf2 i\cf1 f(temp != \cf2 nul\cf1 l)\par
\{\par
temp(this,EventArgs.Empty);\par
\}\par
\}\par
\}\par
\fs20 51. Always have a \cf3 default \cf1 case in a \cf3 switch \cf1 statement that asserts\par
\cf2\fs18 int \cf1 number = SomeMethod();\par
\cf2 switc\cf1 h(number)\par
\{\par
\cf2 case \cf1 1:\par
Trace.WriteLine("Case 1:");\par
\cf2 brea\cf1 k;\par
\cf2 case \cf1 2:\par
Trace.WriteLine("Case 2:");\par
\cf2 brea\cf1 k;\par
\cf2 defaul\cf1 t:\par
\b Debug.Assert(false);\par
\cf2\b0 brea\cf1 k;\par
\}\par
\fs20 52. Avoid providing methods on structures.\par
a) Parameterized constructors are encouraged.\par
b) Can overload operators.\par
53. Always provide a static constructor when providing static member variables.\par
54. Every line of code should be walked through in a \ldblquote white box\rdblquote  testing manner.\par
55. Avoid code that relies on an assembly running from a particular location.\par
56. Do not use late-binding invocation when early-binding is possible.\fs17\par
\fs20 57. Avoid using the trinary conditional operator.\par
58. Do not use the \cf3 this \cf1 reference unless invoking another constructor from within a\par
constructor.\par
\cf4\fs18 //Example of proper use of \rquote this\rquote\par
\cf2 public class \cf1 MyClass\par
\{\par
\cf2 public \cf1 MyClass(\cf2 string \cf1 message)\par
\{\}\par
\cf2 public \cf1 MyClass() : \cf2 thi\cf1 s("hello")\par
\{\}\par
\}\par
\fs20 60. Use application logging and tracing.\par
61. Do not use the \cf3 base \cf1 word to access base class members unless you wish to resolve\par
a conflict with a subclasses member of the same name or when invoking a base class\par
constructor.\par
\cf4\fs18 //Example of proper use of \rquote base\rquote\par
\cf2 public class \cf1 Dog\par
\{\par
\cf2 public \cf1 Dog(\cf2 string \cf1 name)\par
\{\}\par
\cf2 virtual public void \cf1 Bark(\cf2 int \cf1 howLong)\par
\{\}\par
\}\par
\cf2 public class \cf1 GermanShepherd : Dog\par
\{\par
\cf2 public \cf1 GermanShepherd(\cf2 string \cf1 name): \cf2\b bas\cf1 e(name)\par
\b0\{\}\par
\cf2 override public void \cf1 Bark(\cf2 int \cf1 howLong)\par
\{\par
\cf2\b bas\cf1 e.\b0 Bark(howLong);\par
\}\par
\}\par
\fs20 62. Implement \cf3 Dispose() \cf1 and \cf3 Finalize() \cf1 methods \par
63. Avoid casting to and from \cf3 System.Object \cf1 in code that uses generics.\par
64. Use the \cf3 const \cf1 directive only on natural constants such as the number of days of\par
week. Avoid using const on read only variables. For that, use the \cf3 readonly\par
\cf1 directive.\par
\cf2\fs18 public class \cf1 MyClass\par
\{\par
\cf2 public readonly int \cf1 Number;\par
\cf2 public \cf1 MyClass(\cf2 int \cf1 someValue)\par
\{\par
Number = someValue;\par
\}\par
\cf2 const int \cf1 DaysInWeek = 7;\par
\}\fs17\par
\cf2\b\fs29 3 Project Settings and Project Structure\par
\cf1\b0\fs20 1. Always build your project with warning level 4\par
2. Treat warning as errors in Release build (note that this is not the default of VS.NET).\par
a) Although it is optional, this standard recommend treating warnings as errors in\par
debug builds as well.\fs17\par
\fs20 3. Never suppress specific compiler warnings.\par
4. Always explicitly state your supported runtime versions in the application\par
configuration file. \par
\fs18 <?xml version="1.0"?>\par
<configuration>\par
\b <startu\b0 p>\par
\b <supportedRuntime \b0 version="v2.0.0.0"/>\par
<supportedRuntime version="v1.1.5000.0"/>\par
</startup>\par
</configuration>\par
\fs20 5. Avoid explicit custom version redirection and binding to CLR assemblies.\par
6. Avoid explicit preprocessor definitions \cf3 (#defin\cf1 e). Use the project settings for\par
defining conditional compilation constants.\par
7. Do not put any logic inside \cf3\i AssemblyInfo.c\cf1\i0 s.\par
8. Do not put any assembly attributes in any file besides \cf3\i AssemblyInfo.c\cf5\i0 s.\par
\cf1 9. Populate all fields in \cf3\i AssemblyInfo.cs \cf1\i0 such as company name, description, copyright\par
notice.\par
10. All assembly references should use relative path.\par
11. Disallow cyclic references between assemblies.\par
12. Avoid multi-module assemblies.\fs17\par
\fs20 13. Always run code unchecked by default (for performance sake), but explic itly in\par
checked mode for prone operations.\par
\cf2\fs18 int \cf1 CalcPower(\cf2 int \cf1 number,\cf2 int \cf1 power)\par
\{\par
\cf2 int \cf1 result = 1;\par
for(\cf2 int \cf1 count = 1;count <= power;count++)\par
\{\par
\cf2\b checked\par
\cf1\b0\{\par
result *= number;\par
\}\par
\}\par
\cf2 return \cf1 result;\par
\}\par
\fs20 14. Avoid tampering with exception handling using the Exception window\par
(Debug|Exceptions).\par
15. Strive to uniform version numbers on all assemblies and clients in same logical\par
application (typically a solution).\par
16. Name your VS.NET application configuration file as \cf3\i App.Confi\cf1\i0 g, and include it in\par
the project.\par
17. Avoid explicit code exclusion of method calls \cf3 (#i\cf1 f\cf3\'85#endi\cf1 f). Use conditional\par
methods instead.\par
\cf2\fs18 public class \cf1 MyClass\par
\{\par
\b [Conditional("MySpecialCondition")]\par
\cf2\b0 public void \cf1 MyMethod()\par
\{\}\par
\}.\fs17\par
\fs20 18. Modify VS.NET default project structure to your project standard layout, and apply\par
uniform structure for project folders and files.\par
19. Link all solution-wide information to a global shared file:\par
20. Insert spaces for tabs. Use 3 spaces instead of tabs\par
a) Tools|Options|Text Editor|C#|Tabs\fs17\par
\fs20 21. Release build should contain debug symbols.\par
22. Always sign your assemblies, including the client applications.\par
23. Always sign interop assemblies with the project\rquote s SNK file\par
\fs17\par
\cf2\b\fs29 4 Framework Specific Guidelines\par
\fs20 4.1 Data Access\par
\cf1\b0 1. Always use type-safe data sets. Avoid raw ADO.NET.\par
2. Always use transactions when accessing a database.\par
3. Always use transaction isolation level set to Serializable.\par
4. Do not use the Server Explorer to drop connections on windows forms, ASP.NET\par
forms or web services. Doing so couples the presentation tier to the data tier.\par
5. Avoid SQL Server authentication.\par
a) Use Windows authentication instead.\par
6. Run components accessing SQL Server under separate identity from that of the\par
calling client.\par
7. Always warp your stored procedures in a high level, type safe class. Only that class\par
invokes the stored procedures.\par
8. Avoid putting any logic inside a stored procedure.\par
a) If there is an \cf3 IF \cf1 inside a stored procedure, you are doing something wrong.\par
\cf2\b 4.2 ASP.NET and Web Services\par
\cf1\b0 1. Avoid putting code in ASPX files of ASP.NET. All code should be in the code-behind\par
class.\par
2. Code in code behind class of ASP.NET should call other components rather than\par
contain direct business logic.\par
3. In both ASP.NET pages and web services, wrap a session variables in a local\par
property. Only that property is allowed to access the session variable, and the rest of\par
the code uses the property, not the session variable.\par
4. Avoid setting to True the Auto-Postback property of server controls in ASP.NET.\par
5. In transactional pages or web services, always store session in SQL server.\par
6. Turn on Smart Navigation for ASP.NET pages.\par
7. Strive to provide interfaces for web services\par
8. Always provide namespace and service description for web services.\par
9. Always provide a description for web methods.\par
10. When adding a web service reference, provide meaningful name for the location.\par
11. Always modify client-side web service wrapper class to support cookies.\par
a) You have no way of knowing whether the service uses Session state or not.\fs17\par
\cf2\b\fs20 4.3 Serialization\par
\cf1\b0 1. Always mark non-sealed classes as serializable.\par
2. Always mark un-serializable member variables as non serializable.\par
3. Always mark delegates on a serialized class as non-serializable fields:\par
\fs18 [Serializable]\par
\cf2 public class \cf1 MyClass\par
\{\par
\b [field:\b0 NonSerialized]\par
\cf2 public event \cf1 EventHandler MyEvent;\par
\}\par
\cf2\b\fs20 4.4 Multithreading\par
\cf1\b0 1. Use Synchronization Domains.\par
a) Avoid manual synchronization, because they often lead to deadlocks and race\par
conditions.\par
2. Never call outside your synchronization domain.\par
3. Manage asynchronous call completion on a callback method.\par
a) Do not wait, poll, or block for completion.\par
4. Always name your threads.\par
a) Name is traces in the debugger Threads window, making a debug session more\par
productive.\par
\fs18 Thread currentThread = Thread.CurrentThread;\par
\cf2 string \cf1 threadName = "Main UI Thread";\par
currentThread.\b Name \b0 = threadName;\par
\fs20 5. Do not call \cf3 Suspend() \cf1 or \cf3 Resume() \cf1 on a thread.\par
6. Do not call \cf3 Thread.Sleep(\cf1 ).\par
a) \cf3 Thread.Sleep(0) \cf1 is acceptable optimization technique to force a context\par
switch.\par
b) \cf3 Thread.Sleep() \cf1 is acceptable in testing or simulation code.\par
7. Do not call \cf3 Thread.SpinWait(\cf1 ).\par
8. Do not call \cf3 Thread.Abort() \cf1 to terminate threads.\par
a) Use a synchronization object instead to signal the thread to terminate. \par
9. Avoid explicitly setting thread priority to control execution.\par
a) Can set thread priority based on task semantic, such as bellow normal for a\par
screen saver.\par
10. Do not read the value of the thread state property.\par
a) Use \cf3 Thread.IsAlive() \cf1 to determine whether the thread is dead.\par
11. Do not rely on setting the thread type to background thread for application shutdown.\par
a) Use a watchdog or other monitoring entity to deterministically kill threads.\par
12. Do not use thread local storage unless thread affinity is guaranteed.\fs17\par
\fs20 13. Do not call \cf3 Thread.MemoryBarrier(\cf1 ).\par
14. Never call \cf3 Thread.Join() \cf1 without checking that you are not joining your own\par
thread.\par
\cf2\fs18 void \cf1 WaitForThreadToDie(Thread thread)\par
\{\par
Debug.Assert(Thread.\b CurrentThrea\b0 d.GetHashCode() \b != \b0 thread.GetHashCode());\par
thread.Join();\par
\}\par
\fs20 15. Always use the \cf3 lock() \cf1 statement rather than explicit \cf3 Monitor \cf1 manipulation.\par
16. Always encapsulate the \cf3 lock() \cf1 statement inside the object it protects.\par
\cf2\fs18 public class \cf1 MyClass\par
\{\par
\cf2 public void \cf1 DoSomething()\par
\{ \cf2 loc\cf1 k(\cf2 thi\cf1 s)\par
\{\par
\cf4 //Do Something\par
\cf1\}\par
\}\par
\}\par
\fs20 a) Can use synchronized methods instead of writing the \cf3 lock() \cf1 statement\par
yourself.\par
17. Avoid fragmented locking.\par
18. Avoid using a \cf3 Monitor \cf1 to wait or pulse objects. Use manual or auto-reset events\par
instead.\par
19. Always release a \cf3 Mutex \cf1 inside a finally statement to handle exceptions.\par
20. Do not use volatile variables. Lock your object or fields instead to guarantee\par
deterministic and thread-safe access.\par
a) Do not use \cf3 Thread.VolatileRead(\cf1 ), \cf3 Thread.VolatileWrite() \cf1 or\par
the \cf3 volatile \cf1 modifier.\par
21. Never stack \cf3 lock \cf1 statements, because that does not provide atomic locking. Use\par
\cf3 WaitHandle.WaitAll() \cf1 instead.\par
\fs18 MyClass obj1 = \cf2 new \cf1 MyClass();\par
MyClass obj2 = \cf2 new \cf1 MyClass();\par
MyClass obj3 = \cf2 new \cf1 MyClass();\par
\cf4 //Do not stack lock statements\par
\cf2 loc\cf1 k(obj1)\par
\cf2 loc\cf1 k(obj2)\par
\cf2 loc\cf1 k(obj3)\par
\{\par
obj1.DoSomething();\par
obj2.DoSomething();\par
obj3.DoSomething();\par
\}\fs17\par
\cf2\b\fs20 4.5 Remoting\par
\cf1\b0 1. Prefer administrative configuration to programmatic configuration.\par
2. Always implement \cf3 IDisposable \cf1 on a single call objects.\par
3. Always prefer TCP channel and binary format when using remoting.\par
a) Unless a firewall is present.\par
4. Always provide a null lease for a singleton object.\par
\cf2\fs18 public class \cf1 MySingleton : MarshalByRefObject\par
\{\par
\cf2 public override object \cf1 InitializeLifetimeService()\par
\{\par
\cf2 return \b nul\cf1\b0 l;\par
\}\par
\}\par
\fs20 5. always provide a sponsor for a client activated object. Sponsor should return initial\par
lease timed.\par
6. Always unregister a sponsor on client application shutdown.\par
7. Always put remote objects in class libraries.\par
8. Avoid using SoapSuds.\par
9. Avoid hosting in IIS.\par
10. Avoid using uni-directional channels.\par
11. Always load a remoting configuration file in \cf3 Main() \cf1 even if the file is empty, and\par
the application does not use remoting.\par
a) Allow the option of remoting some types later on post deployment, and\par
changing the application topology.\par
\cf2\fs18 static void \cf1 Main()\par
\{\par
RemotingConfiguration.Configure("MyApp.exe.config");\par
\cf4 /* Rest of Main() */\par
\cf1\}\par
\fs20 12. Avoid using \cf3 Activator.GetObject() \cf1 and\par
\cf3 Activator.CreateInstance() \cf1 for remote objects activation. Use \cf3 new\par
\cf1 instead.\par
13. Always register port 0 on the client side, to allow callbacks.\fs17\par
\fs20 14. Always elevate type filtering to full on both client and host to allow callbacks.\par
\fs18 Host Config file:\par
<channels>\par
<channel ref="tcp" port="8005">\par
<serverProviders>\par
<formatter ref="soap" \b typeFilterLevel="Full\b0 "/>\par
<formatter ref="binary" \b typeFilterLevel="Full\b0 "/>\par
</serverProviders>\par
</channel>\par
<channel ref="http" port="8006">\par
<serverProviders>\par
<formatter ref="soap" \b typeFilterLevel="Full\b0 "/>\par
<formatter ref="binary" \b typeFilterLevel="Full\b0 "/>\par
</serverProviders>\par
</channel>\par
</channels>\par
Client Config file:\par
<channels>\par
<channel ref="tcp" port="0">\par
\b <serverProvider\b0 s>\par
<formatter ref="soap" \b typeFilterLevel="Full\b0 "/>\par
<formatter ref="binary" \b typeFilterLevel="Full\b0 "/>\par
</serverProviders>\par
</channel>\par
</channels>.\fs17\par
\cf2\b\fs20 4.6 Security\par
\cf1\b0 1. Always demand your own strong name on assemblies and components that are\par
private to the application, but are public (so that only you can use them).\par
\cf2\fs18 public class \cf1 PublicKeys\par
\{\par
\cf2 public const string \cf1 MyCompany = "1234567894800000940000000602000000240000"+\par
"52534131000400000100010007D1FA57C4AED9F0"+\par
"A32E84AA0FAEFD0DE9E8FD6AEC8F87FB03766C83"+\par
"4C99921EB23BE79AD9D5DCC1DD9AD23613210290"+\par
"0B723CF980957FC4E177108FC607774F29E8320E"+\par
"92EA05ECE4E821C0A5EFE8F1645C4C0C93C1AB99"+\par
"285D622CAA652C1DFAD63D745D6F2DE5F17E5EAF"+\par
"0FC4963D261C8A12436518206DC093344D5AD293";\par
\}\par
\b [StrongNameIdentityPermission(SecurityAction.LinkDemand,\par
PublicKey = PublicKeys.MyCompany)]\par
\cf2\b0 public class \cf1 MyClass\par
\{\'85\}\par
\fs20 2. Apply encryption and security protection on application configuration files.\par
3. Assert unmanaged code permission, and demand appropriate permission instead.\par
4. On server machines deploy code-access security policy that grants only Microsoft,\par
ECMA and self (identified by strong name) full trust.\par
a) All other code is implicitly granted nothing.\par
5. On client machine, deploy a security policy which grants client application only the\par
permissions to call back the server and to potentially display user interface.\par
a) Client application identified by strong name.\par
6. Always refuse at the assembly level all permissions not required to perform task at\par
hand.\par
a) The counter a luring attack.\par
\fs18 [assembly:UIPermission(SecurityAction.\b RequestRefus\b0 e,\par
Window=UIPermissionWindow.AllWindows)]\par
\fs20 7. Always set the principal policy in every \cf3 Main() \cf1 method to Windows\par
\cf2\fs18 public class \cf1 MyClass\par
\{\par
\cf2 static void \cf1 Main()\par
\{\par
AppDomain currentDomain = Thread.GetDomain();\par
currentDomain.\b SetPrincipalPolic\b0 y(PrincipalPolicy.WindowsPrincipal);\par
\}\par
\cf4 //other methods\par
\cf1\}\par
\fs20 8. Never assert a permission without demanding a different permission in its place\par
\fs17\par
\cf2\b\fs20 4.7 Enterprise Services\par
\cf1\b0 1. Do not catch exceptions in a transactional method. Use the \cf3 AutoComplete\par
\cf1 attribute.\par
\par
2. Do not call \cf3 SetComplete(\cf1 ), \cf3 SetAbort(\cf1 ), and the like. Use the\par
\cf3 AutoComplete \cf1 attribute.\par
\fs18 [Transaction]\par
\cf2 public class \cf1 MyComponent : ServicedComponent\par
\{\par
[AutoComplete]\par
\cf2 public void \cf1 MyMethod(\cf2 long \cf1 objectIdentifier)\par
\{\par
GetState(objectIdentifier);\par
DoWork();\par
SaveState(objectIdentifier);\par
\}\par
\}\par
\fs20 3. Always override \cf3 CanBePooled \cf1 and return \cf3 true \cf1 (unless you have a good reason\par
not to return to pool)\par
\cf2\fs18 public class \cf1 MyComponent :ServicedComponent\par
\{\par
\cf2 protected override bool \cf1 CanBePooled()\par
\{\par
\cf2\b return tru\cf1 e;\par
\b0\}\par
\}\par
\fs20 4. Always call \cf3 Dispose() \cf1 explicitly on a pooled objects unless the component is\par
configured to use JITA as well.\par
5. Set authentication level to privacy on all applications.\par
6. Use Enterprise Services whenever more than one object or more than one database is\par
involved in a single transaction.\par
7. Set impersonation level on client assemblies to Identity.\par
8. Always set \cf3 ComponentAccessControl \cf1 attribute on serviced components to true\par
a) The default is True\par
9. Always add to the \cf3 Marshaler \cf1 role the Everyone user\par
\fs18 [assembly: SecurityRole("Marshaler",SetEveryoneAccess = true)]\par
\fs20 10. Apply \cf3 SecureMethod \cf1 attribute to all classes requiring authentication.\fs17\par
\lang1033\f0\fs18\par
\par
Finish\par
\lang2057\par
}
 